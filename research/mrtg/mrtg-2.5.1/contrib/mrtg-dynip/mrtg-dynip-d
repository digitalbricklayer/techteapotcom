#!/usr/local/bin/perl

##################################################################
# Multi Dynamic IP Traffic Grapher contibution to mrtg
##################################################################
#
# Created by John Heenan <john@heenan.ironbark.id.au>
#
# Available from http://www.heenan.ironbark.id.au/mrtg-dynip
#
##################################################################
#
# Distributed under the GNU copyleft
#
# mrtg-dynip, v 0.35x 1997/10/12 
# 
# Copyright John Heenan, with exception of datestr subroutine
# (copied from mrtg executable) and much of internal_walk
# subroutine (manner of using snmp modules copied from an example
# by Simon Lenine)
#
###################################################################

#mrtg-d is mrtg-dynip with most of the internal comments removed.
#For the fully commented version, please see file mrtg-dynip.

#Mrtg-dynip is a contribution to mrtg, enabling mrtg to generate multi
#interface traffic graphs for various hosts which do not provide a
#consistent interface name for physical interfaces, such as in a dynamic IP
#environment.  The hosts must run snmp agents.  For completeness,
#information about interface devices with unvarying interface names, such as
#ethernet cards, can be configured to be included.

#There are 12 scaler configuartion constants below. The last one is a
#multiline scaler constant.  See the install file or use the fully commented
#version if nexessary

$HTTP_Work_Dir='/var/lib/httpd/htdocs/mrtg/';

$HTTP_index_file='index.html';

$mrtg_Dir="/usr/src/mrtg/mrtg-2.4.1/";

$mrtgcfg_Dir=$mrtg_Dir;

$mrtgcfg_file="mrtg-dynip.cfg";

$update=5;

$community_default="public";

$email="admin\@our_org.com";

$home_page="www.our_org.com";

$home_page_descr="Our home page";

$suicidal = 1; 

$firewall_masq_tran_if = 0;

{
$interfaces = <<END_OF_INTERFACES


END_OF_INTERFACES
}

###### You have reached the end of the configuration section, there is no
#need to make any adjustments below for normal operation.

@lines = split(/\n/,$interfaces);
$line=0;
while ($line <= $#lines)
{
  @elements = split (" ",$lines[$line]);
  if (defined ($elements[3]))
  {
    $descr=$lines[$line+1];
    $descr =~ s/^\s*//;
    $community = defined ($elements[4]) ? $elements[4] : $community_default;
    $ip_descr{$elements[1]."@".$elements[3]} = [$elements[0],$elements[2],$community,$descr];
    $snmp_comm_host{$community."@".$elements[3]}{$elements[1]}=1;
    $line=$line+2;
  }
  else
  {
    $line++;
  }
}

#Use Simon Leinen's Perl 5 snmp modules included with mrtg
#consistent with manner Simon uses in examples
{
&snmp_get_response;
}

open MRTGCFG, ">$mrtg_Dir"."$mrtgcfg_file"
         || die "$mrtg_Dir"."$mrtgcfg_file file could not be opened\n";

$ip_descr_ptr = \%ip_descr;

foreach $ip_i (keys(%target))
{
if ($$ip_descr_ptr{$ip_i}->[0] =~ /^\d/) 
{
($speed_fig,$speed_mult) = $$ip_descr_ptr{$ip_i}->[1] =~ /^(\d+)(\D*)/;
if ($speed_mult =~ /M|m/)
{
  $scale = int ( $speed_fig * 1024 * 1024 / 8 );
}
elsif ($speed_mult =~ /K|k/)
{
  $scale = int ( $speed_fig * 1024 / 8 );
}
elsif ( $speed_mult eq "" )
{
  $scale = int ( $speed_fig / 8 );
}
else
{
  die("Incorrect speed format in scaler constant $interfaces\n");
}

($ip_if,$host) = split (/@/,$ip_i);
if ($firewall_masq_tran_if != 0)
{
$snmp_target=$ip_i;
}
else
{
$snmp_target=$ip_if;
}

print MRTGCFG <<END
Target[$snmp_target]: $target{$ip_i}:$$ip_descr_ptr{$ip_i}->[2]\@$host
MaxBytes[$snmp_target]: $scale
Title[$snmp_target]: Traffic Analysis through interface device with IP address $ip_if of host $host
PageTop[$snmp_target]: <H1>Stats for interface device with description $$ip_descr_ptr{$ip_i}->[3]</H1>

END
}
}
{
print MRTGCFG <<END

WorkDir: $HTTP_Work_Dir
END
}
close MRTGCFG;

$interval = $update * 60;
$expires = gmtime (time + $interval + 60);
$now=&datestr(time);

open MRTGCFGWEB, ">$HTTP_Work_Dir"."$HTTP_index_file"
	 || die "Mrtg web index file could not be created\n";
{
print MRTGCFGWEB <<END
<HTML><HEAD> 
<META HTTP-EQUIV=\"Refresh\" CONTENT=\"$interval\">
<META HTTP-EQUIV=\"Expires\" CONTENT=\"$expires GMT\"> 

<TITLE>Index of stats pages for interface devices on interfaces described below</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000"> 
<FONT FACE="Arial,Helvetica">
<H1>Active and inactive interace device stats on interfaces described below</H1>
This page last updated on $now<p>
END
}

if ($home_page && $home_page_descr)
{
print MRTGCFGWEB <<END
<p>
A network management service courtesy of <a href=\"http://$home_page\">
$home_page_descr</a>
<p>
END
}

if ($email)
{
print MRTGCFGWEB <<END
<p>
Information and contact address: Network management at email 
<a href=\"mailto:$email\">$email</a>
<p>
END
}

{
print MRTGCFGWEB <<END
</FONT>
<table>
END
}

foreach $ip_i (keys %ip_descr)
{
$ip_order{$$ip_descr_ptr{$ip_i}->[0]} = $ip_i if ($$ip_descr_ptr{$ip_i}->[0] =~ /^\d/);
}

foreach $i (sort (keys %ip_order))
{
$ip_i = $ip_order{$i};

if ($firewall_masq_tran_if != 0)
{
$file_name=$ip_i;
}
else
{
($file_name) = split (/@/,$ip_i);
}

if ( defined ($target{$ip_i}) )
{
print MRTGCFGWEB <<END
<tr><td><FONT FACE="Arial,Helvetica">ACTIVE</FONT></td> <td><FONT FACE="Arial,Helvetica"><A HREF=\"$file_name.html\">$$ip_descr_ptr{$ip_i}->[3]</a></FONT></td></tr>
END
}
else
{
print MRTGCFGWEB <<END
<tr><td><FONT FACE="Arial,Helvetica">INACTIVE</FONT></td> <td><FONT FACE="Arial,Helvetica"><A HREF=\"$file_name.html\">$$ip_descr_ptr{$ip_i}->[3]</a></td></FONT></tr>
END
}
}
{
print MRTGCFGWEB <<END
</table>
<FONT FACE="Arial,Helvetica">
<p> This web page (but not the web pages above)
generated by mrtg-dynip, version 0.35x, 1997/10/12 
created by <br>John Heenan, <a
href="mailto:john\@heenan.ironbark.id.au">john\@heenan.ironbark.id.au</a>

<P>Mrtg-dynip is a contribution to mrtg, enabling mrtg to generate multi
interface traffic graphs for various hosts which do not provide a consistent
interface name for physical interfaces, such as in a dynamic IP environment. 
The hosts must run snmp agents.  For completeness, information about
interface devices with unvarying interface names, such as ethernet cards,
can be configured to be included.<P>

This web page and web pages above, auto update details, and refresh, every
$update minutes.<p>

Source code for the latest version of the mrtg-dynip software contribution is
available from <a href="http://www.heenan.ironbark.id.au/source/mrtg-dynip">
http://www.heenan.ironbark.id.au/source/mrtg-dynip</a><p> 
END
}

print MRTGCFGWEB "</FONT></BODY></HTML>","\n";

close MRTGCFGWEB; 

exec ("$mrtg_Dir"."mrtg $mrtgcfg_Dir"."$mrtgcfg_file");

sub datestr {
($time) = shift(@_) || return 0;
($wday) = ('Sunday','Monday','Tuesday','Wednesday',
                'Thursday','Friday','Saturday')[(localtime($time))[6]];
($month) = ('January','February' ,'March' ,'April' ,
                 'May' , 'June' , 'July' , 'August' , 'September' ,
                 'October' ,
                 'November' , 'December' )[(localtime($time))[4]];
($mday,$year,$hour,$min) = (localtime($time))[3,5,2,1];
if ($min<10) {$min = "0$min";}
return "$wday, $mday $month ".($year+1900)." at $hour:$min";
}

sub snmp_get_response
{
use BER;
use SNMP_Session;

SOLDIER_ON: foreach $comm_host (keys (%snmp_comm_host))
{
($community,$host) = split (/@/,$comm_host);
if ($session = SNMP_Session->open ($host, $community, 161))
{
@ipRouteIfIndex = split ('\.', '1.3.6.1.2.1.4.21.1.2');
@ipAdEntIfIndex = split ('\.', '1.3.6.1.2.1.4.20.1.2');
$if_route_index_index = encode_oid (@ipRouteIfIndex);
$if_index_index = encode_oid (@ipAdEntIfIndex);

  @oids = ($if_route_index_index);
  for (;;) {
    if ($session->getnext_request_response (@oids)) {
        $response = $session->pdu_buffer;
        ($bindings) = $session->decode_get_response ($response);
        @next_oids = ();
        ($binding,$bindings) = decode_sequence ($bindings);
        ($oid,$value) = decode_by_template ($binding, "%O%@");
        last unless BER::encoded_oid_prefix_p ($if_route_index_index, $oid);
        push @next_oids, $oid;
        ($ip_if) = pretty_print ($oid) =~ /.*\.(\d+\.\d+\.\d+\.\d+)$/;
        $target_i = pretty_print ($value);
        $target{$ip_if."@".$host} = $target_i if ( defined ($snmp_comm_host{$community."@".$host}{$ip_if}) );
    } else 
        {
          die ("Suicide: no response from community $community on host $host","\n") if ($suicidal != 0);
          print ("Soldiering on: no response from community $community on host $host","\n");
          $session->close ();
          last SOLDIER_ON;
        }
    @oids = @next_oids;
  }

  @oids = ($if_index_index);
  for (;;) {
    if ($session->getnext_request_response (@oids)) {
        $response = $session->pdu_buffer;
        ($bindings) = $session->decode_get_response ($response);
        @next_oids = ();
        ($binding,$bindings) = decode_sequence ($bindings);
        ($oid,$value) = decode_by_template ($binding, "%O%@");
        last unless BER::encoded_oid_prefix_p ($if_index_index, $oid);
        push @next_oids, $oid;
        ($ip_if) = pretty_print ($oid) =~ /.*\.(\d+\.\d+\.\d+\.\d+)$/;
        $target_i = pretty_print ($value);
        $target{$ip_if."@".$host} = $target_i if ( defined ($snmp_comm_host{$community."@".$host}{$ip_if}) );
    } else 
        {
          die ("Suicide: no response from community $community on host $host","\n") if ($suicidal != 0);
          print ("Soldiering on: no response from community $community on host $host","\n");
	  $session->close ();
          last SOLDIER_ON;
        }
    @oids = @next_oids;
  }
$session->close ();
}
else
  {
     die ("Suicide: unable to open SNMP session to community $community on host $host","\n") if ($suicidal != 0);
     print ("Soldiering on: unable to open SNMP session to community $community on host $host","\n");
  }
}
}
