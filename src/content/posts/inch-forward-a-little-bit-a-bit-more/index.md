---
title: "Inch forward a bit, a bit more..."
date: "2006-12-19T17:45:39+00:00"
aliases: [/posts/21/, inch-forward-a-little-bit-a-bit-more/]
---

Programming is still way too hard. Even the smallest piece of software takes a huge amount of effort to build.

Software tools are not great. The tools I use now are not really that far away from what I first started using professionally in 1992. Back then it was a command line compiler with make scripts and [Brief](http://www.softpedia.com/get/Programming/File-Editors/Brief-text-editor.shtml) as the text editor. Now it is a [Integrated Development Environment](https://en.wikipedia.org/wiki/Integrated_development_environment) wrapping the same command line compiler. Not much change there.

Yep, there are lots of [UML](http://www.uml.org/) tools. But, from my experience, they are as likely to hinder productivity as encourage it especially on small/medium projects. You can't beat a notepad and a pencil for software design.

Debugging tools are certainly better but not by much. A debugger from ten years ago is pretty close in terms of features to its modern equivalent. The Edit and Continue feature sounds like a great idea but in practice I rarely use it.

The big hope was [Object Oriented Programming](https://en.wikipedia.org/wiki/Object-oriented_programming) combined with feature rich libraries. They still are ðŸ˜‰

One very interesting field that holds real promise, when combined with object orientation, are [design patterns](https://en.wikipedia.org/wiki/Design_pattern_(computer_science)). I can remember reading the [GoF book](https://en.wikipedia.org/wiki/Design_Patterns) and being absolutely bowled over by it. Obvious really, but only when somebody else has thought of it.

Another interesting idea that has gained a lot of traction recently is [automated testing](http://www.testing.com/writings/automate.pdf). Most interesting of all is the concept of [continuous integration](http://www.martinfowler.com/articles/continuousIntegration.html). Every time code is added to the software repository build it and make sure it works properly. Great! The tools are slowly getting there, though only for [Java](http://java.sun.com/) and [.NET](http://www.microsoft.com/net/) environments.

[Test first programming](http://www.extremeprogramming.org/rules/testfirst.html) is also a very good idea, though not always easy to achieve. The idea being to write the tests before you write the code. Then, when all of the tests work you know you're done. The great thing about this is that you have a body of code that you know works, and you will keep a tight reign on the features you put into the software. Controlling the specification in software is a much under appreciated art.

My belief is that software won't get better by the invention of a single tool that revolutionises the software industry. Rather it will be a continual evolution of tools, technique and practice over the next few decades.
